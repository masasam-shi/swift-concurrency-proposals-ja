original: <https://forums.swift.org/t/swift-concurrency-roadmap/41611>

---

# Swift Concurrency Roadmap

私たちの目標は、Swiftでの並行プログラミングを便利で効率的で安全なものにすることです。

このドキュメントでは、非同期関数やアクターの実装を通じて、これを達成するために提案されているいくつかの追加や言語の変更について概説しています。これらの追加は個別に提案されますが、多くの場合、お互いに依存しています。このドキュメントはそれらを結合するためのものです。複数の可能性のある方向性や、場合によってはありそうもない方向性を記述するマニフェストとは異なり、このドキュメントでは、Swiftの同時実行に取り組むための単一の意図した計画を記述しています。

これらの変更の最終的な状態は以下のようになります。

- 非同期プログラミングを使用する際に便利で明確なものにすることです。
- Swift開発者が従うことができる言語ツールと技術の標準セットを提供します。
- コンパイル時の知識を高め、非同期コードのパフォーマンスを向上させます。
- Swiftがメモリの安全性の問題を排除するのと同じように、データの競合やデッドロックを排除します。

これらの機能の導入は、複数の Swift リリースにまたがることになります。機能は大きく分けて2つのフェーズで導入されます。最初のフェーズでは、非同期構文とアクタ型が導入されます。これにより、ユーザーはアクタを中心にコードを整理してデータ競合を減らすことができますが、データ競合をなくすことはできません。第二段階では、アクタを完全に分離してデータ競合を排除し、分離を実用的なものにするために必要なアクタの効率的で人間工学的な相互運用を可能にするための多くの機能とともに、アクタの完全な分離を強制します。

ロードマップとして、このドキュメントでは、これらの提案と同じレベルの詳細には触れていません。また、第二段階の機能についても議論していますが、この分野の詳細な提案は第一段階がより明確に定義されるまで待たなければなりません。

非同期ストリーム、ループのための並列化、分散アクタなど、このドキュメントでは取り上げられていない多くの関連トピックがあります。これらの機能の多くは、このロードマップで説明されているものを補完するものであり、いつでも導入される可能性がある。

## モチベーションとなる例

並行処理のために推奨されている基本的なパターンは良いものです。ロックの代わりにキューを使ってデータを保護したり、スレッドをブロックする代わりに非同期コールバックを使って遅い処理の結果を返したりしています。

しかし、これらのことを手動で行うのはひどく、エラーが発生しやすいものです。これらのパターンを示す次のコードを考えてみましょう。

```swift
internal func refreshPlayers(completion: (() -> Void)? = nil) {
    refreshQueue.async {
        self.gameSession.allPlayers { players in
            self.players = players.map(\.nickname)
            completion?()
        }
    }
}
```

このコードについて3つわかることがあります。

- __うわべだけのコードが多すぎる__。この関数は基本的には、関数を呼び出して結果を変換し、それをプロパティに代入するだけです。しかし、キューや完了ハンドラなど余分な作業が多すぎて、それがわかりづらいのです。

- この余計なコードがあるからこそ、__バグを生みやすくなります__。補完ハンドラの中に`self.players`プロパティへの直接の代入があります。それはどのスレッドにあるのか不明瞭です。これはデータ競合の可能性があります。コールバックは代入を行う前に正しいキューにディスパッチする必要があるかもしれません。おそらくこれは`allPlayers`によって処理されているのでしょうが、このコードがスレッドセーフであるかどうかはローカルでは判断できません。

- このコードは__不必要に非効率__です。いくつかの関数オブジェクトを個別に割り当てる必要があります。これらの関数で使用される`self`のような参照は、それらの中にコピーされなければならず、余分な参照カウント操作が必要になります。関数は複数回実行されることもあれば、全く実行されないこともあり、コンパイラがこれらのコピーを回避できないこともよくあります。

さらに、これらの問題は不可避的に結びついています。非同期コールバックは最終的には常に一度だけ正確に実行されるので、恒久的な参照サイクルに参加することができません。Swiftはこのことを知らないので、クロージャの中で明示的に`self`を必要とします。プログラマの中には、反射的に`[weak self]`を追加することでこれに対応する人もいます。このような関数は、`self`が`nil`になるとすぐに返すことが多く、任意の量のコードがスキップされている可能性があるため、その正しさについて推論することが難しくなります。

ですから、ここで示されているパターンは良いものですが、Swiftで表現すると重要な構造が失われ、問題が生じます。解決策は、これらのパターンを言語に持ち込むことです。そうすれば、陳腐な表現を減らし、言語がパターンを安全なものにすることができ、バグを排除し、プログラマーは並行処理をより広く使う自信を持つことができるようになります。また、同時実行コードのパフォーマンスを向上させる機会も得られるでしょう。

以下は、私たちが提案した新しい構文を使って書き換えた上記のコードです。

```swift 
internal func refreshPlayers() async {
  players = await gameSession.allPlayers().map(\.nickname)
}
```

この例で注意すべきことは以下のとおりです。

- `refreshPlayers`は非同期関数になりました。
- `allPlayers`も非同期関数であり、完了ハンドラに渡す代わりに結果を返します。
- このため、式の合成を使用して、返された値に直接マップ関数を呼び出すことができます。
- `await`キーワードは、`allPlayers`を呼び出す式の前に出現し、`refreshPlayers`関数がこの時点でサスペンドされる可能性があることを示しています。
- `await`は`try`と同様に動作しますが、サスペンド可能な式の開始時に一度だけ出現する必要があり、その式内でサスペンド可能なすべての呼び出しの前に直接出現する必要はありません。
- 明示的な`self.`はプロパティアクセスから削除されました。
- プロパティ`allPlayers`と`players`へのアクセスは、データ競合を持つことができなくなりました。

最後のポイントがどのようにして達成されたかを理解するために、我々はレイヤーを一歩踏み出して、キューがどのようにして状態を保護するために使用されているかを見なければなりません。

元のコードは、内部状態を保護するために`refreshQueue`を使用するクラス上のメソッドでした。

```swift
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession
  var refreshQueue = DispatchQueue(label: "PlayerRefresh")
    
  func refreshPlayers(completion: (() -> Void)? = nil) { 
    ... 
  }
}
```

これは一般的なパターンです。プライベートなキューを持つクラスと、キュー上でしかアクセスできないはずのいくつかのプロパティを持つクラスです。私たちは、この手動のキュー管理をアクタークラスに置き換えます。

```swift 
actor class PlayerRefreshControler {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async { ... }
}
```

この例について注意すべきことは、

- クラスをアクタであると宣言することは、クラスにプライベート・キューを与え、そのキューを介してそのプライベート状態へのすべてのアクセスを同期させることに似ています。
- この同期はコンパイラによって理解されるので、キューを使用して状態を保護することを忘れてはいけません。コンパイラは、クラスのメソッドの中でキュー上で実行されていることを確認し、そのメソッドの外で状態にアクセスできないようにします。
- コンパイラがこれを行うため、メソッドが別のアクタで非同期関数を呼び出して開始する場合のように、よりスマートに同期を最適化することができます。

アクタとその関数やプロパティの間にこのような静的な関係を持つことで、アクタに対するデータの分離を強制し、離れたデータ競合を定義することができます。アクタのプロパティに安全にアクセスできるコンテキストにいるかどうかを静的に知ることができ、そうでない場合は、コンパイラがそのコンテキストへの切り替えを処理します。

上では、アクタークラスを示しましたが、ここではプロパティとコードのセットがしっかりとカプセル化されています。しかし、今日のUIプログラミングの方法では、多くの場合、1つのメインスレッドから使用することになっている多数のクラスにコードを分散させています。このメイン スレッドはアクタの一種であり、グローバル アクタと呼ばれています。

クラスや関数をそのアクタに関連付けられているものとして属性でマークすることができます。コンパイラはどこからでもこのクラスを参照できるようにしますが、実際にこのメソッドを呼び出すには UI アクタ上にいる必要があります。つまり、`PlayerRefreshControler`のすべてのアクションがグローバル UIアクタ上で実行されることが適切であるとすれば、次のように表現することになります。

```swift 
@UIActor
class PlayerRefreshControler {
  var players: [String] = []
  var gameSession: GameSession
    
  func refreshPlayers() async {  ...  }
}
```

## 第一段階の提案

第1フェーズのサポートとして、以下の提案を近日中にピッチする予定です。

- __`async`/`await`__は、Swiftにコルーチンベースの`async`/`await`モデルを導入しています。関数は非同期であることを選択し、他の非同期関数の結果を待つことができ、非同期コードをより自然な「直線的」な形で表現することができます。

- __`Task` API and Structured Concurrency__ では、標準ライブラリにタスクの概念を導入します。この章では、切り離されたタスクを作成するためのAPI、子タスクを動的に作成するためのタスク "ナーサリー"、タスクのキャンセルや優先順位付けの仕組みについて説明します。また、構造化された同時実行の原則に基づいて、複数の子タスクからの値を待つためのスコープベースのメカニズムも紹介します。

- __Actors & Actor Isolation__ では、同時実行プログラムの状態分離を提供するアクタモデルについて説明します。これは、データ競合の可能性を排除するためのメカニズムであるアクタ分離の基礎を提供します。この第 1 フェーズの提案では、部分的なアクタ分離を導入し、完全な分離の実施は後続の提案に委ねます。

- __Concurrency Interoperability with Objective-C__は、Swiftの同時実行機能（例：非同期関数）とObjective-Cの非同期関数の慣習ベースの表現の間の自動化されたブリッジングを導入します。これにより、コールバックベースのバージョンと並んで非同期関数へのAPIの代替のSwift変換を提供することで、既存の非同期Objective-C APIがSwiftの同時実行モデルですぐに使えるようになります。

- __`Async handlers`__は、非同期ハンドラとして同期アクター関数を宣言する機能を導入しています。これらの関数は外部では同期関数のように動作しますが、内部では非同期関数のように処理されます。これにより、`UITableViewDelegate`のような従来の「通知」メソッドが、面倒な設定なしに非同期操作を実行できるようになります。

## Actorの分離の第2段階

Swiftの目標は、デフォルトで変更可能な状態のデータ競合を防ぐことです。これを実現するためのシステムは、__アクター分離__と呼ばれています。これは、アクターがシステムがどのように機能するかについてとても重要であり、アクターで保護された状態がアクターの外部からアクセスされるのを防ぐことにシステムが深く関係しているからです。しかし、アクタ分離は、アクタが直接関与していない場合でも、同時実行時のシステムの正しさのために必要な場合には、コードを制限します。

このロードマップに記載されている機能は、2つのフェーズで導入する予定です。第一に非同期関数とアクタを作成する機能を導入し、第二にアクタの完全な分離を強制します。

アクタ分離の基本的な考え方は、メモリへの排他的アクセスの考え方に似ており、それを基に構築されています。Swift の並行処理の設計は、アクターの自然な分離から始め、補完的なツールとして所有権を使用することで、安全な並行処理への使いやすく構成可能なアプローチを提供することを目的としています。

アクタの分離の問題は、すべての通常の変更可能なメモリが特定のアクタやタスクによってのみアクセスされることを保証する問題に還元されます。これは、メモリがどのようにアクセスされているか、誰が最初にアクセスできるかの分析につながります。メモリをいくつかのグループに分類することができます。

- アクタのプロパティは、そのアクタによって保護されます。
- 不変メモリ（let定数など）、ローカルメモリ（決して参照されないローカル変数など）、値コンポーネントメモリ（structのプロパティやenumケースなど）は、データ競合からすでに保護されています。
- 安全でないメモリ（`UnsafeMutablePointer`によって参照される任意の割り当てなど）は、安全でない抽象化に関連付けられています。なぜなら、これらの抽象化は必要に応じて安全な言語ルールを迂回するために使用できるように意図されているからです。その代わり、プログラマがこれらを正しく使うことを信頼しなければなりません。
- グローバルメモリ（グローバル変数やスタティック変数など）は、原則としてどのコードでもどこからでもアクセスできるので、データ競合の対象となります。
- また、クラスコンポーネントのメモリは、クラスへの参照を保持している任意のコードからアクセスすることができます。つまり、クラスへの参照はアクタによって保護されているかもしれませんが、アクタ間でその参照を渡すと、そのプロパティがデータ競合にさらされることになります。これは、アクタ間で渡された値型内に保持されているクラスも参照することに注意してください。

__完全なアクタ分離の目的__は、これらの最後の2つの分類がデフォルトで保護されていることを保証することです。

## 第一段階　基本的なアクター分離

第一段階では、安全性の利点を導入します。ユーザはグローバル変数をグローバルアクタで保護し、アクタクラスに変換することでクラスメンバを保護することができるようになります。特定のキューへのアクセスを必要とするフレームワークは、 グローバルアクタを定義し、それに対してデフォルトのプロトコルを定義することができます。

この段階では、アクタ分離の重要なケースの多くが強制されます。

```swift
actor class MyActor {
  let immutable: String = "42"
  var mutableArray: [String] = []

  func synchronousFunction() {
	  mutableArray += ["syncFunction called"]
  }
}

extension MyActor {

  func asyncFunction(other: MyActor) async {
    // allowed: an actor can access its internal state, even in an extension
    self.mutableArray += ["asyncFunction called"]
  
    // allowed: immutable memory can be accessed from outside the actor
    print(other.immutable)

    // error: an actor cannot access another's mutable state
    other.mutableArray += ["not allowed"]

    // error: either reading or writing
    print(other.mutableArray.first)
    
    // allowed: async functions can call async functions on other actors
    await other.asyncFunction(other: self)
    
    // error: only asynchronous functions can be called from outside the actor
    other.synchronousFunction()    
  }
}
```

アクターと非同期関数は新しい機能なので、これらの施行は_ソースを破壊しません_。

## 第二段階　完全なアクター分離

アクターの導入後も、グローバル変数や参照型の値を介して、競合状態になる可能性がある。

```swift
var racyGlobal: [String] = []

@MyGlobalActor
Var safeGlobal: [String] = []

class PlainOldClass {
  var unprotectedState: String = []
}

actor RacyActor {
  let immutableClassReference: PlainOldClass

  func racyFunction(other: RacyActor) async {
    // protected: global variable protected by a global actor
    safeGlobal += ["Safe access"]
  
    // unprotected: global variable not in an actor
    racyGlobal += ["Racy access"]
    
    // unprotected: racyProperty is immutable, but it is a reference type
    // so it allows access to unprotected shared mutable type
    other.takeClass(immutableClassReference)
  }
  
  func takeClass(_ class: PlainOldClass) {
    class.unprotectedState += ["Racy access"]  
  }
}
```

最初のフェーズでは、Swiftの_現在_のデフォルトの動作を維持することを意図しています。グローバル変数とクラスコンポーネントのメモリはデータ競合から保護されていません。これが現在のSwiftのデフォルトなので、第一段階ではソースに破壊的変更をもたらしません。

第2フェーズでは、さらなる機能の導入により、完全に隔離されたアクターを扱うためのツールのフルセットが提供されます。これらの中で最も重要なのは、型を「アクターローカル」に制限する機能です。型がアクタローカルとマークされている場合、コンパイラはアクタ間で型が渡されるのを防ぎます。その代わり、参照は境界線を越えて渡される前に何らかの方法でクローンされているか、もしくは共有されていない必要があります。

これにより、デフォルトの変更が可能になります。

- グローバル変数は、グローバルアクタによって保護されているか、"アクタセーフではない"とマークされている必要があります。
- クラス（およびクラス参照を含む型）は、デフォルトでは "アクタが安全でない"状態から "アクタがローカル"に変更されます。

このデフォルトの変更は__ソースの破壊的変更__を必要とし、言語モードによってゲートされる必要があります。変更可能なグローバル変数に触れたり、アクタの境界を越えてクラス参照を共有したりするコードは、基本的にデータ競合から安全であることを示すことができず、それ（および将来書かれるコード）がデータ競合から安全であることを確実にするために変更する必要があります。このソースブレークが負担にならないことが望まれます。

- グローバル変数の使用は控えめにすべきであり、ほとんどのグローバル変数はグローバルアクタによって保護されます。
- クラスがアクタの境界を越えて共有されない限り、"アクタローカル"アノテーションはアクタ内のコードに影響を与えるべきではありません。
- 参照が境界を越えて渡されなければならない場合、言語はこれを明らかにし、解決策をシンプルにしなければなりません。
- 値型の使用をさらに奨励し、単純化することで、アクタの境界を越えてクラスを共有する必要性を減らすことができます。

2 つのフェーズの間の時間は、ユーザーが自分のコードをアクタや非同期関数に組み込む機会を与え、完全な分離の準備をすることになります。
第1フェーズのピッチとは異なり、第2フェーズで必要とされる言語機能は、最初はSwiftフォーラムの進化の議論セクションで議論のために提起されます。2段階のアプローチの主な推進力の1つは、完全な分離モデルに移行する前に、Swiftユーザーに非同期関数やアクターに慣れるための時間を与えたいということです。大規模な作業コードベースをアクタや非同期関数に移植した経験が、アクタの完全な分離を強制するために必要な機能を教えてくれることが期待されています。このフィードバックは、第二段階での機能の議論に情報を提供します。

第二段階で議論される予定の機能には、以下のようなものがあります。

- 型に対するアクタローカルな制限の導入。
- `MutableIfUnique`クラスの型による正しい「Copy on Write」を保証するためのコンパイラのサポート。
- スレッドセーフティーが他の手段で処理されている場合など、アクタ分離をオプトアウトするための属性。

## 概念の用語集

これらはデザイン全体で使用される基本的な概念であり、ここでは簡単に定義されています。

- __同期関数（synchronous function）__は、Swiftプログラマーがすでに慣れ親しんでいる関数の種類です。シングルスレッドで完結するまで実行され、呼び出す同期関数以外はインターリーブコードを使用しません。
- __スレッド（thread）__とは、基礎となるプラットフォームのスレッドの概念を指します。プラットフォームは様々ですが、基本的な特徴を共有する傾向があります。真の同時実行にはプラットフォームのスレッドを作成する必要がありますが、プラットフォームのスレッドの作成と実行にはコストがかかります。C言語の関数呼び出しや、通常のSwiftの同期関数では、プラットフォームスレッドの使用が必要になります。
- __非同期関数（asynchronous function）__は新しい種類の関数で、割り込み（？）せずに完了まで実行する必要はありません。割り込みが発生すると関数は__中断（suspend）されます__。非同期関数がスレッドを放棄するポイントが__サスペンドポイント（susspension point）__です。
- __タスク（task）__とは、非同期に実行される操作のことです。すべての非同期関数は、あるタスクの一部として実行されます。非同期関数が別の非同期関数を呼び出した場合、呼び出しがアクターを変更しなければならなかったとしても、その呼び出しは同じタスクの一部として実行されます。タスクは非同期関数のスレッドに相当します。
- 非同期関数は__子タスク（child task）__を作成することができます。子タスクは親タスクの優先度を含めた構造の一部を継承しますが、親タスクと並行して実行することができます。しかし、この同時実行には制限があります。子タスクを作成した関数は、子タスクが終了するのを待ってから返さなければなりません。
- プログラムが独立した並行作業を開始して、そのスポーン・コンテキストを長持ちさせることができるようにしたい場合は、拘束された子タスクではなく、__分離したタスク（detached task）__を使用します。
- __部分タスク（partial task）__は、スケジューリング可能な作業の単位です。タスク内で現在実行中の関数が中断されると、それがパーシャルタスクの終了であり、タスク全体の作業を継続するために新しいパーシャルタスクが作成されます。
- __エクセキューター（executor）__とは、部分タスクの結果を受け付けて、それを実行するためのスレッドを手配するサービスです。現在実行中の非同期関数は、常に実行中のエクセキューターを知っています。エクセキューターは、それに投入された部分タスクが決して同時に実行されない場合、__排他的（exclusive）__です。
- __アクター__は、コードを実行できるプログラムの独立した部分です。アクタは一度に1つのコードを実行することができますが、実行されるコードは他のアクタによって実行されるコードと同時に実行することができます。
- アクタは、そのアクタによってのみアクセス可能な保護された状態を持つことができます。これが達成されるシステムは、__アクタの分離（actor isolation）__と呼ばれます。長期的な目標は、Swiftがデフォルトでアクタの分離を保証することです。
- __アクタクラス（actor class）__は参照型で、それぞれのインスタンスは別々のアクタです。その保護された状態はインスタンスのプロパティであり、アクタ関数はインスタンスのメソッドです。
- __グローバルアクタ（global actor）__はグローバルオブジェクトです。その保護された状態とアクタ関数は、多くの異なるタイプに分散している可能性があります。これらはアクタ固有の属性でマークすることができ、Swiftは多くの場合に推論することができます。